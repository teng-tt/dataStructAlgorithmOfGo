package main

import "fmt"

/*
希尔排序：
	属于插入类排序，高级排序算法，是直接插入排序的改进版本
	平均时间复杂度O(n^1.3)
	最好时间复杂度O(nlogn)
	最坏时间复杂度O(n^2)
	空间复杂度O(1),原地交换排序
	不稳定排序算法，排序改变原大小的排序位置
	适用于n中等规模时

希尔排序是直接插入排序的改进版本
因为直接插入排序对那些几乎已经排好序的数列来说，排序效率极高，
达到了 O(n) 的线性复杂度，但是每次只能将数据移动一位
希尔排序创造性的可以将数据移动 n 位，然后将 n 一直缩小，缩到与直接插入排序一样为 1

有一个 N 个数的数列：
先取一个小于 N 的整数 d1，将位置是 d1 整数倍的数们分成一组，对这些数进行直接插入排序。
接着取一个小于 d1 的整数 d2，将位置是 d2 整数倍的数们分成一组，对这些数进行直接插入排序。
接着取一个小于 d2 的整数 d3，将位置是 d3 整数倍的数们分成一组，对这些数进行直接插入排序。
...
直到取到的整数 d=1，接着使用直接插入排序。
这是一种分组插入方法，最后一次迭代就相当于是直接插入排序，其他迭代相当于每次移动 n 个距离的直接插入排序，
这些整数是两个数之间的距离，我们称它们为增量。取数列长度的一半为增量，以后每次减半，直到增量为1。

越有序的数列，直接插入排序的效率越高，希尔排序通过分组使用直接插入排序，因为步长比 1 大，
在一开始可以很快将无序的数列变得不那么无序，比较和交换的次数也减少，
直到最后使用步长为 1 的直接插入排序，数列已经是相对有序了，所以时间复杂度会稍好一点

希尔排序不是稳定的，因为每一轮分组，都使用了直接插入排序，但分组会跨越 n 个位置，导致两个相同的数，
发现不了对方而产生了顺序变化

一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，
但在大规模还是要使用快速排序，归并排序或堆排序。
*/

// ShellSort 增量序列折半的希尔排序
func ShellSort(num []int) {
	lenth := len(num) //获取数组长度
	// 每次减半，直到步长为1
	for step := lenth/2; step >= 1; step /= 2 {
		// 开始插入排序，每一轮步长为step
		for i := step; i < lenth; i += step {
			// j := i - step 待排序数左边的第step步长后数的位置，因为步长=step
			for j := i - step; j >= 0; j -= step {
				// 满足插入那么交换元素,将更小的交换的更前面
				if num[j+step] < num[j] {
					num[j], num[j+step] = num[j+step], num[j]
					continue
				}
				break
			}
		}
	}
}

func main() {
	// 测试
	list := []int{5}
	ShellSort(list)
	fmt.Println(list)

	list1 := []int{5, 9}
	ShellSort(list1)
	fmt.Println(list1)

	list2 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
	ShellSort(list2)
	fmt.Println(list2)

	list3 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3, 2, 4, 23, 467, 85, 23, 567, 335, 677, 33, 56, 2, 5, 33, 6, 8, 3}
	ShellSort(list3)
	fmt.Println(list3)
}
